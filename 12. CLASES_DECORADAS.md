# Clases Decoradoras
Los decoradores son un patr贸n de dise帽o de software que alteran
din谩micamente y agregan funcionalidades adicionales a los m茅todos, funciones
o clases de Python sin tener que usar subclases o cambiar el c贸digo fuente
decorada.
Estos generalmente son herramientas muy 煤tiles para el desarrollador ya que
son muy f谩ciles de implementar, son legibles, reducen c贸digo, entre otras
ventajas. En Python hay m煤ltiples formas de crear decoradores.

A trav茅s de los decoradores seremos capaces reducir las l铆neas de c贸digo duplicadas, haremos que nuestro c贸digo sea legible, f谩cil de testear y f谩cil de mantener

En Python una funci贸n puede ser asignada a una variable, puede ser utilizada como argumento para otra funci贸n, o inclusive puede ser retornada. 

EJEMPLO

Tenemos una funci贸nc como la conocemos

    def saludar():
      print('hola')

    saludar()

salida

    hola a todos
    
pero que pasa si deseamos modificar los par谩metros de salida, es decir si quieramos que ahora la funci贸n imprima algo m谩s? tendriamos que modificar directamente la funci贸n

    def saludar():
      print('saludo')
      print('hola')
      print('despedida')

Hay una manera m谩s r谩pida y f谩cil de modificar las funciones, para ello se usan los decoradores.

creamos el decorador

        def decorador(func):
          def saludo():
            print('saludo')
            func()
            print('despedida')
          return saludo

func es una palabra reservada que indica se pasar谩 una funcion como argumento, en este caso sera la funci贸n saludar.

Par decorar la funcion saludar se ingresa con el @ el nombre de la funci贸n decoradora

        @decorador
        def saludar():
          print('hola')
        saludar()

salida

        saludo
        hola
        despedida
        
  As铆, el empleo de 芦@禄 seguido del nombre del decorador aplicado sobre la funci贸n 芦saludar禄 vendr铆a a equivaler a 芦saludar=decorador(saludar)禄
        
 EJEMPLO

    def division(a,b):
      return a/b

    dicision(10,5)

salida

    2.0
    
Ah铆 obtendriamos el resultado, pero si cambiamos y dividios entre cero nos marcar谩 un error.

    def division(a,b):
      return a/b

    division(10,0)

salida

    ZeroDivisionError: division by zero
    
Para solucionar esta situaci贸n tendriamos que ir directamente a la funci贸n y a帽adir fucionalidad, quiza una condici贸n para validar, pero se debe entrar a la funci贸n para la modificaci贸n
o crear un decorador 

      def revisar(func): #func es una palabra reservada que le indica pasaremos como argumento otra funci贸n
          def validacion(a,b):  #Como vimos en Python podemos tener funciones dentro de funciones y hasta funciones como argumentos
              if b == 0:
                print('no es posible dividir entre 0')
                return  #para salir de la funci贸n
              func(a,b) #se ejecuta en caso contrario la funci贸n que tenemos como argumento
          return validacion  #vuelve a ejecutar la funcion de validaci贸n pero ya con los argumentos de func


Ah铆 esta creado el decorador, solo basta pasarlo a la funci贸n primera para su uso

    @revisar
    def division(a,b):
      return a/b

    division(10,0)
    
salida

    no es posible dividir entre 0
    
Si notas cuando ya no divida entre 0 nos mandar谩 de resultado none, esto es porque ahora la validaci贸n la hace el decorador, basta con un else y que regrese la divisi贸n
    
Otro ejemplo


      def saludar(): 
          print('Hola soy una funci贸n') 

      def super_funcion(funcion): 
          funcion() 

      funcion = saludar  # Asignamos la funci贸n a una variable!

      super_funcion(funcion)  
      
Un decorador no es m谩s que una funci贸n la cual toma como input una funci贸n y asu vez retorna otra funci贸n, al momento de implementar un decorador estaremos trabajando, con por lo menos, 3 funciones. El input, el output y la funci贸n principal. 

    def funcion_a(funcion_b):
        def funcion_c():
            print('Antes de la ejecuci贸n de la funci贸n a decorar')
            funcion_b()
            print('Despu茅s de la ejecuci贸n de la funci贸n a decorar')

        return funcion_c
        
Ya tenemos el decorador creado, ahora lo que nos hace falta es decorar una funci贸n. Al nosotros utilizar la palabra decorar estamos indicando que queremos modificar el comportamiento de una funci贸n ya existente, pero sin tener que modificar su c贸digo. Esto es muy 煤til, principalmente, cuando queremos extender nuevas funcionalidades a dicha funci贸n. De all铆 el nombre decorar.

Una buena analog铆a ser铆a ver este tema como un pastel, donde, en ocasiones, la base del pastel (el pan) no es suficiente para una fiesta y debemos a帽adir elementos extras, quiz谩s glaseado, velas, aderezos etc ... de esta forma el pastel se ver谩 mucho mejor y lo m谩s importante sabr谩 mucho mejor. 

En la analog铆a la base del pastel no ser谩 m谩s que nuestra funci贸n a decorar y los elementos extras los decoradores.

Para decorar una funci贸n basta con colocar, en su parte superior de dicha funci贸n, el decorador con el prefijo @.


      def funcion_a(funcion_b):
          def funcion_c():
              print('Antes de la ejecuci贸n de la funci贸n a decorar')
              funcion_b()
              print('Despu茅s de la ejecuci贸n de la funci贸n a decorar')

          return funcion_c

      @funcion_a
      def saludar():
          print('Hola mundo!!')

      saludar()
      
 Salida
 
    Antes de la ejecuci贸n de la funci贸n a decorar
    Hola mundo!!
    Despu茅s de la ejecuci贸n de la funci贸n a decorar
